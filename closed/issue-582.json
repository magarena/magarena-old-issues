{
  "status": "verified",
  "body": "I wrote a class to further my needs, but truth to be told, it's merely a slightly altered copy of MagicCardChoice. And it needs quite some polishing...\r\n\r\nmagic.model.choice.MagicFromCardListChoice\r\n\r\npackage magic.model.choice;\r\n\r\nimport magic.model.MagicCard;\r\nimport magic.model.MagicCardList;\r\nimport magic.model.MagicGame;\r\nimport magic.model.MagicPlayer;\r\nimport magic.model.MagicSource;\r\nimport magic.model.event.MagicEvent;\r\nimport magic.ui.GameController;\r\nimport magic.ui.UndoClickedException;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.Collections;\r\nimport java.util.HashSet;\r\nimport java.util.List;\r\nimport java.util.Set;\r\n\r\npublic class MagicFromCardListChoice extends MagicChoice {\r\n\r\n    private static final String MESSAGE=\"Choose a card.\";\r\n    private final MagicCardList cardList;\r\n    private final int amount;\r\n\r\n    public MagicFromCardListChoice(final MagicCardList cardList,final int amount) {\r\n        super(genDescription(amount));\r\n        this.cardList=cardList;\r\n        this.amount=amount;\r\n    }\r\n\r\n    private static final String genDescription(final int amount) {\r\n        if (amount==1) {\r\n            return \"Choose a card.\";\r\n        } else {\r\n            return \"Choose \" + amount + \" cards.\";\r\n        }\r\n    }\r\n\r\n    private void createOptions(\r\n            final Collection<Object> options,\r\n            final MagicCardList cList,\r\n            final MagicCard[] cards,\r\n            final int count,\r\n            final int aAmount,\r\n            final int index) {\r\n\r\n        if (count == aAmount) {\r\n            options.add(new MagicCardChoiceResult(cards));\r\n            return;\r\n        }\r\n\r\n        final int left = cList.size() - index;\r\n        if (count + left < aAmount) {\r\n            return;\r\n        }\r\n\r\n        cards[count]=cList.get(index);\r\n        createOptions(options,cList,cards,count+1,aAmount,index+1);\r\n        createOptions(options,cList,cards,count,aAmount,index+1);\r\n    }\r\n\r\n    @Override\r\n    Collection<Object> getArtificialOptions(\r\n            final MagicGame game,\r\n            final MagicEvent event,\r\n            final MagicPlayer player,\r\n            final MagicSource source) {\r\n\r\n        final List<Object> options = new ArrayList<Object>();\r\n        final MagicCardList cList = new MagicCardList(this.cardList);\r\n        Collections.sort(cList);\r\n        final int actualAmount = Math.min(amount,cList.size());\r\n        if (actualAmount > 0) {\r\n            createOptions(options,cList,new MagicCard[actualAmount],0,actualAmount,0);\r\n        } else {\r\n            options.add(new MagicCardChoiceResult());\r\n        }\r\n        return options;\r\n    }\r\n\r\n    @Override\r\n    public Object[] getPlayerChoiceResults(\r\n            final GameController controller,\r\n            final MagicGame game,\r\n            final MagicPlayer player,\r\n            final MagicSource source) throws UndoClickedException {\r\n\r\n        final MagicCardChoiceResult result=new MagicCardChoiceResult();\r\n        final Set<Object> validCards=new HashSet<Object>(this.cardList);\r\n        int actualAmount=Math.min(amount,validCards.size());\r\n        for (;actualAmount>0;actualAmount--) {\r\n            final String message=result.size()>0?result.toString()+\"|\"+MESSAGE:MESSAGE;\r\n            controller.showCards(this.cardList);\r\n            controller.focusViewers(5,-1);\r\n            controller.disableActionButton(false);\r\n            controller.setValidChoices(validCards,false);\r\n            controller.showMessage(source,message);\r\n            controller.waitForInput();\r\n            final MagicCard card = controller.getChoiceClicked();\r\n            validCards.remove(card);\r\n            result.add(card);\r\n        }\r\n        controller.clearCards();\r\n        controller.focusViewers(0,-1);\r\n        return new Object[]{result};\r\n    }\r\n}",
  "author": "[Landhotel.Westerwald](https://code.google.com/u/Landhotel.Westerwald/)",
  "title": "Enhancement request: please do review and add magic.model.choice.MagicFromCardListChoice for further testing",
  "labels": [
    "imported",
    "Priority-Medium",
    "bug"
  ],
  "comments": [
    {
      "date": "April 08, 2014 16:11:42",
      "body": "Additionally I wrote 2 examples, for what I need it. First Bane Alley Broker, tested, works perfectly with MagicFromCardListChoice\r\n\r\nname=Bane Alley Broker\r\nurl= http://magiccards.info/query?q=%21bane%20alley%20broker image= http://mtgimage.com/card/bane%20alley%20broker.jpg value=3.500\r\nrarity=U\r\ntype=Creature\r\nsubtype=Human,Rogue\r\ncost={1}{U}{B}\r\npt=0/3\r\ntiming=main\r\nrequires_groovy_code\r\n\r\ngroovy:\r\n\r\ndef HAS_EXILED_BEFORE_CONDITION = new MagicCondition() {\r\n    public boolean accept(final MagicSource source) {\r\n        final MagicPermanent permanent = (MagicPermanent)source;\r\n        return permanent.getExiledCards().size() > 0;\r\n    }\r\n};\r\ndef public class ExileCardFromHandAction extends MagicAction {\r\n    private final MagicPermanent source;\r\n    private final MagicPermanent permanent;\r\n    private final MagicCard card;\r\n    private final MagicLocationType location;\r\n\r\n    public ExileCardFromHandAction(final MagicPermanent source,final MagicCard card){\r\n        this.source = source;\r\n        this.permanent = MagicPermanent.NONE;\r\n        this.card = card;\r\n        this.location = MagicLocationType.OwnersHand;\r\n    }\r\n    \r\n    public void doAction(final MagicGame game) {\r\n        game.doAction(new MagicRemoveCardAction(card,location));\r\n        game.doAction(new MagicMoveCardAction(card,location,MagicLocationType.Exile));\r\n        source.addExiledCard(card);\r\n    }\r\n    \r\n    public void undoAction(final MagicGame game) {\r\n        source.removeExiledCard(card);\r\n    }\r\n};\r\ndef public class ReclaimExiledCardAction extends MagicAction {\r\n    private final MagicPermanent source;\r\n    private final MagicPermanent permanent;\r\n    private final MagicCard card;\r\n    private final MagicLocationType location;\r\n\r\n    public ReclaimExiledCardAction(final MagicPermanent source,final MagicCard card){\r\n        this.source = source;\r\n        this.permanent = MagicPermanent.NONE;\r\n        this.card = card;\r\n        this.location = MagicLocationType.Exile;\r\n    }\r\n    \r\n    public void doAction(final MagicGame game) {\r\n        game.doAction(new MagicRemoveCardAction(card,location));\r\n        game.doAction(new MagicMoveCardAction(card,location,MagicLocationType.OwnersHand));\r\n        source.removeExiledCard(card);\r\n    }\r\n    \r\n    public void undoAction(final MagicGame game) {\r\n        source.addExiledCard(card);\r\n    }\r\n};\r\n[\r\n    new MagicPermanentActivation(\r\n        new MagicActivationHints(MagicTiming.Draw),\r\n        \"Draw & Exile\"\r\n    ) {\r\n\r\n        @Override\r\n        public Iterable<MagicEvent> getCostEvent(final MagicPermanent source) {\r\n            return [\r\n                new MagicTapEvent(source)\r\n            ];\r\n        }\r\n\r\n        @Override\r\n        public MagicEvent getPermanentEvent(final MagicPermanent source,final MagicPayedCost payedCost) {\r\n            return new MagicEvent(\r\n                source,\r\n                0,\r\n                this,\r\n                \"PN draws a card, then exiles a card from his or her hand.\"\r\n            );\r\n        }       \r\n        public MagicEvent exileCardFromHandEvent(final MagicPermanent source) {\r\n            return new MagicEvent(\r\n                source,\r\n                MagicTargetChoice.A_CARD_FROM_HAND,\r\n                MagicExileTargetPicker.create(),\r\n                1,\r\n                this,\r\n                \"PN exiles a card\\$ from his or her hand.\"\r\n            );\r\n        }\r\n\r\n        @Override\r\n        public void executeEvent(final MagicGame game, final MagicEvent event) {\r\n            if(event.getRefInt() == 0) {\r\n               game.doAction(new MagicDrawAction(event.getPlayer(),1));\r\n               game.addEvent(exileCardFromHandEvent(event.getPermanent()));\r\n            }\r\n            if(event.getRefInt() == 1) {\r\n                event.processTargetCard(game, {\r\n                    final MagicCard card ->\r\n                    game.doAction(new ExileCardFromHandAction(event.getPermanent(),card));\r\n                });\r\n            }\r\n        }\r\n    },\r\n    new MagicPermanentActivation(\r\n        [HAS_EXILED_BEFORE_CONDITION],\r\n        new MagicActivationHints(MagicTiming.Draw),\r\n        \"Reclaim\"\r\n    ) {\r\n        @Override\r\n        public Iterable<MagicEvent> getCostEvent(final MagicPermanent source) {\r\n            return [\r\n                new MagicTapEvent(source),\r\n                new MagicPayManaCostEvent(source,\"{U}{B}\")\r\n            ];\r\n        }\r\n        @Override\r\n        public MagicEvent getPermanentEvent(final MagicPermanent permanent,final MagicPayedCost payedCost) {\r\n            return new MagicEvent(\r\n                permanent,\r\n                new MagicFromCardListChoice(permanent.getExiledCards(),1),\r\n                this,\r\n                \"PN returns a card\\$ exiled with Bane Alley Broker to its owner's hand.\"\r\n            );\r\n        }       \r\n        @Override\r\n        public void executeEvent(final MagicGame game, final MagicEvent event) {\r\n            if(event.getCardChoice().size() > 0) {\r\n                final MagicCard card = event.getCardChoice().get(0);\r\n                game.doAction(new ReclaimExiledCardAction(event.getPermanent(),card));\r\n            }\r\n        }\r\n    }\r\n]",
      "author": "[Landhotel.Westerwald](https://code.google.com/u/Landhotel.Westerwald/)"
    },
    {
      "date": "April 08, 2014 16:13:23",
      "body": "The second one: Mind Grind. No compiler errors, no crashes either, but it doesn't execute the full code, and I don't know yet why.\r\n\r\nname=Mind Grind\r\nurl= http://magiccards.info/query?q=%21mind%20grind image= http://mtgimage.com/card/mind%20grind.jpg value=3.788\r\nremoval=3\r\nrarity=R\r\ntype=Sorcery\r\ncost={X}{U}{B}\r\ntiming=removal\r\nrequires_groovy_code\r\n\r\ngroovy:\r\n\r\n[\r\n    new MagicSpellCardEvent() {\r\n        @Override\r\n        public MagicEvent getEvent(final MagicCardOnStack cardOnStack,final MagicPayedCost payedCost) {\r\n            return new MagicEvent(\r\n                cardOnStack,\r\n                MagicTargetChoice.TARGET_OPPONENT,\r\n                0,\r\n                this,\r\n                \"PN looks at the top X cards of target opponent's\\$ library. He or she exiles one of those cards and put the rest back on top of that player's library in any order. X can't be 0.\"\r\n            );\r\n        }\r\n        public MagicEvent getExileChoice(final MagicSource source, final MagicCardList cardList) {\r\n            return new MagicEvent(\r\n                source,\r\n                new MagicFromCardListChoice(cardList,1),\r\n                1,\r\n                this,\r\n                \"PN exiles a card.\\$\"\r\n            );\r\n        }\r\n        public MagicEvent putBackChoice(final MagicSource source, final MagicCardList cardList) {\r\n            return new MagicEvent(\r\n                source,\r\n                new MagicFromCardListChoice(cardList,cardList.size()),\r\n                2,\r\n                this,\r\n                \"PN put the rest back on top of owner's library in any order.\"\r\n            );\r\n        }\r\n        @Override\r\n        public void executeEvent(final MagicGame game, final MagicEvent event) {\r\n            final int amount = event.getCardOnStack().getX();\r\n            final MagicCardList cardList = new MagicCardList();\r\n            final MagicPlayer player;\r\n            final MagicCard card;\r\n            if(event.getRefInt()==0){\r\n                event.processTargetPlayer(game,{\r\n                    final MagicPlayer target ->\r\n                    player = target;\r\n                    if(player.getLibrary().size() >= amount){\r\n                        for(int i=amount-1;i>=0;i--) {\r\n                            cardList.addToTop(player.getLibrary().get(i));\r\n                        }\r\n                    } else {\r\n                        for(int i=player.getLibrary().size()-1;i>=0;i--) {\r\n                            cardList.addToTop(player.getLibrary().get(i));\r\n                        }\r\n                    }\r\n                    game.addEvent(getExileChoice(event.getSource(),cardList));\r\n                });             \r\n            } else if(event.getRefInt()==1 && event.getCardChoice().size() > 0){\r\n                card = event.getCardChoice().get(0);\r\n                game.doAction(new MagicRemoveCardAction(card,MagicLocationType.OwnersLibrary));\r\n                game.doAction(new MagicMoveCardAction(card,MagicLocationType.OwnersLibrary,MagicLocationType.Exile));\r\n                cardList.remove(card);\r\n                if(cardList.size() > 0){ \r\n                    game.addEvent(putBackChoice(event.getSource(),cardList));\r\n                }\r\n            } else if(event.getRefInt()==2 && event.getCardChoice().size() > 0) {\r\n                for(int i=event.getCardChoice().size()-1;i>=0;i--) {\r\n                    game.doAction(new MagicRemoveCardAction(event.getCardChoice().get(0),MagicLocationType.OwnersLibrary));\r\n                    game.doAction(new MagicMoveCardAction(event.getCardChoice().get(0),MagicLocationType.OwnersLibrary,MagicLocationType.TopOfOwnersLibrary));\r\n                    event.getCardChoice().remove(0);\r\n                }\r\n            }\r\n        }\r\n    }\r\n]",
      "author": "[Landhotel.Westerwald](https://code.google.com/u/Landhotel.Westerwald/)"
    },
    {
      "date": "April 09, 2014 01:30:07",
      "body": "actually, the second card is sealed fate... \r\n\r\nname=Sealed Fate\r\nurl= http://magiccards.info/query?q=%21sealed%20fate image= http://mtgimage.com/card/sealed%20fate.jpg value=3.312\r\nremoval=3\r\nrarity=U\r\ntype=Sorcery\r\ncost={X}{U}{B}\r\ntiming=removal\r\nrequires_groovy_code\r\n\r\nsomehow I mixed them. Was late yesterday ;)",
      "author": "[Landhotel.Westerwald](https://code.google.com/u/Landhotel.Westerwald/)"
    },
    {
      "date": "April 09, 2014 09:21:35",
      "body": "Another working example of MagicFromCardListChoice...\r\n\r\nname=Brainbite\r\nurl= http://magiccards.info/query?q=%21brainbite image= http://mtgimage.com/card/brainbite.jpg value=2.956\r\nrarity=C\r\ntype=Sorcery\r\ncost={2}{U}{B}\r\ntiming=draw\r\nrequires_groovy_code\r\n\r\n\r\n[\r\n    new MagicSpellCardEvent() {\r\n        @Override\r\n        public MagicEvent getEvent(final MagicCardOnStack cardOnStack,final MagicPayedCost payedCost) {\r\n            return new MagicEvent(\r\n                cardOnStack,\r\n                cardOnStack.getController(),\r\n                new MagicFromCardListChoice(cardOnStack.getController().getOpponent().getHand(),1),\r\n                cardOnStack.getController().getOpponent(),\r\n                this,\r\n                \"RN reveals his or her hand. PN chooses a card\\$ from it. RN discards that card.\"+\r\n                \"PN draws a card.\"\r\n            );\r\n        }\r\n        @Override\r\n        public void executeEvent(final MagicGame game, final MagicEvent event) {\r\n            if(event.getCardChoice().size() > 0) {\r\n                game.doAction(new MagicDiscardCardAction(event.getRefPlayer(),event.getCardChoice().get(0)));\r\n            }\r\n            game.doAction(new MagicDrawAction(event.getPlayer(),1));\r\n        }\r\n    }\r\n]",
      "author": "[Landhotel.Westerwald](https://code.google.com/u/Landhotel.Westerwald/)"
    },
    {
      "date": "April 09, 2014 13:39:41",
      "body": "Posted my reply to Brainbite on google groups by mistake:\r\n\r\nViewing the AI's hand gives the player an unfair advantage over the AI. The AI can't/doesn't remember what it sees if it casts it on the player. All those cards will become 1/1 creatures with shroud and can't be countered which cost {13} - the default for unknown cards.\r\n\r\nThe other cards are looking good :) Though bear in mind the current limitations of the AI, we want it to win! ;)",
      "author": "[ShawnieBoyUK](https://code.google.com/u/ShawnieBoyUK/)"
    },
    {
      "date": "April 09, 2014 13:52:21",
      "body": "okay, didn't know that. nevertheless, there are quite some cards which could use a CardListChoice. If you say \"go\" I will follow it through, though I could use a hand in polishing that MagicFromCardListChoice - for example, it doesn't yet reset the showCards. Ah well, with time... it's still experimental.",
      "author": "[Landhotel.Westerwald](https://code.google.com/u/Landhotel.Westerwald/)"
    },
    {
      "date": "April 10, 2014 20:51:00",
      "body": "MagicFromCardList and other cards from your clone has been merged. I've not check if all the cards posted to this issue is included, if not just add them to the clone and they will be merged shortly.\n\n**Status:** Done  \n",
      "author": "[melvinzh...@gmail.com](https://code.google.com/u/108278210804167927868/)"
    },
    {
      "date": "April 11, 2014 02:32:29",
      "body": "I didn't push all of them yet, as they aren't yet working as I like them to be.",
      "author": "[Landhotel.Westerwald](https://code.google.com/u/Landhotel.Westerwald/)"
    },
    {
      "date": "August 29, 2014 04:29:37",
      "body": "**Status:** Verified  \n",
      "author": "[ShawnieBoyUK](https://code.google.com/u/ShawnieBoyUK/)"
    }
  ],
  "content": "_From [Landhotel.Westerwald](https://code.google.com/u/Landhotel.Westerwald/) on April 09, 2014 07:09:56_\n\nI wrote a class to further my needs, but truth to be told, it's merely a slightly altered copy of MagicCardChoice. And it needs quite some polishing...\r\n\r\nmagic.model.choice.MagicFromCardListChoice\r\n\r\npackage magic.model.choice;\r\n\r\nimport magic.model.MagicCard;\r\nimport magic.model.MagicCardList;\r\nimport magic.model.MagicGame;\r\nimport magic.model.MagicPlayer;\r\nimport magic.model.MagicSource;\r\nimport magic.model.event.MagicEvent;\r\nimport magic.ui.GameController;\r\nimport magic.ui.UndoClickedException;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.Collections;\r\nimport java.util.HashSet;\r\nimport java.util.List;\r\nimport java.util.Set;\r\n\r\npublic class MagicFromCardListChoice extends MagicChoice {\r\n\r\n    private static final String MESSAGE=\"Choose a card.\";\r\n    private final MagicCardList cardList;\r\n    private final int amount;\r\n\r\n    public MagicFromCardListChoice(final MagicCardList cardList,final int amount) {\r\n        super(genDescription(amount));\r\n        this.cardList=cardList;\r\n        this.amount=amount;\r\n    }\r\n\r\n    private static final String genDescription(final int amount) {\r\n        if (amount==1) {\r\n            return \"Choose a card.\";\r\n        } else {\r\n            return \"Choose \" + amount + \" cards.\";\r\n        }\r\n    }\r\n\r\n    private void createOptions(\r\n            final Collection<Object> options,\r\n            final MagicCardList cList,\r\n            final MagicCard[] cards,\r\n            final int count,\r\n            final int aAmount,\r\n            final int index) {\r\n\r\n        if (count == aAmount) {\r\n            options.add(new MagicCardChoiceResult(cards));\r\n            return;\r\n        }\r\n\r\n        final int left = cList.size() - index;\r\n        if (count + left < aAmount) {\r\n            return;\r\n        }\r\n\r\n        cards[count]=cList.get(index);\r\n        createOptions(options,cList,cards,count+1,aAmount,index+1);\r\n        createOptions(options,cList,cards,count,aAmount,index+1);\r\n    }\r\n\r\n    @Override\r\n    Collection<Object> getArtificialOptions(\r\n            final MagicGame game,\r\n            final MagicEvent event,\r\n            final MagicPlayer player,\r\n            final MagicSource source) {\r\n\r\n        final List<Object> options = new ArrayList<Object>();\r\n        final MagicCardList cList = new MagicCardList(this.cardList);\r\n        Collections.sort(cList);\r\n        final int actualAmount = Math.min(amount,cList.size());\r\n        if (actualAmount > 0) {\r\n            createOptions(options,cList,new MagicCard[actualAmount],0,actualAmount,0);\r\n        } else {\r\n            options.add(new MagicCardChoiceResult());\r\n        }\r\n        return options;\r\n    }\r\n\r\n    @Override\r\n    public Object[] getPlayerChoiceResults(\r\n            final GameController controller,\r\n            final MagicGame game,\r\n            final MagicPlayer player,\r\n            final MagicSource source) throws UndoClickedException {\r\n\r\n        final MagicCardChoiceResult result=new MagicCardChoiceResult();\r\n        final Set<Object> validCards=new HashSet<Object>(this.cardList);\r\n        int actualAmount=Math.min(amount,validCards.size());\r\n        for (;actualAmount>0;actualAmount--) {\r\n            final String message=result.size()>0?result.toString()+\"|\"+MESSAGE:MESSAGE;\r\n            controller.showCards(this.cardList);\r\n            controller.focusViewers(5,-1);\r\n            controller.disableActionButton(false);\r\n            controller.setValidChoices(validCards,false);\r\n            controller.showMessage(source,message);\r\n            controller.waitForInput();\r\n            final MagicCard card = controller.getChoiceClicked();\r\n            validCards.remove(card);\r\n            result.add(card);\r\n        }\r\n        controller.clearCards();\r\n        controller.focusViewers(0,-1);\r\n        return new Object[]{result};\r\n    }\r\n}\n\n_Original issue: http://code.google.com/p/magarena/issues/detail?id=582_",
  "date": "2014-04-09T07:09:56",
  "state": "closed",
  "gid": 582,
  "link": "http://code.google.com/p/magarena/issues/detail?id=582",
  "owner": ""
}
