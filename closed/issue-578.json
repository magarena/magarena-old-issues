{
  "status": "wontfix",
  "body": "I got through the groovy code once more and I have an idea how to manage:\r\n\r\nBow_of_Nylea.groovy:\r\n\r\n[\r\n    new MagicStatic(MagicLayer.Ability,MagicTargetFilter.TARGET_CREATURE_YOU_CONTROL) {\r\n        @Override\r\n        public void modAbilityFlags(final MagicPermanent source,final MagicPermanent permanent,final Set<MagicAbility> flags) {\r\n            if(permanent.isAttacking()) {\r\n               permanent.addAbility(MagicAbility.Deathtouch, flags);\r\n            }\r\n        }\r\n    },\r\n    new MagicPermanentActivation(\r\n        new MagicActivationHints(MagicTiming.Main),\r\n        \"Return\"\r\n    ){\r\n        private int cardCount=0;\r\n        @Override\r\n        public Iterable<MagicEvent> getCostEvent(final MagicPermanent source) {\r\n            return [\r\n                new MagicTapEvent(source), \r\n                new MagicPayManaCostEvent(source,\"{1}{G}\")\r\n            ];\r\n        }\r\n        @Override\r\n        public MagicEvent getPermanentEvent(final MagicPermanent source,final MagicPayedCost payedCost) {\r\n            return new MagicEvent(\r\n                source,\r\n                new MagicMayChoice(MagicTargetChoice.TARGET_CARD_FROM_GRAVEYARD),\r\n                MagicGraveyardTargetPicker.ExileOpp,\r\n                this,\r\n                \"Put up to 4 target cards\\$ from your graveyard on the bottom of your library\"\r\n            );\r\n        }\r\n        @Override\r\n        public void executeEvent(final MagicGame game, final MagicEvent event) {\r\n            if(event.isYes()){\r\n                event.processTargetCard(game, {\r\n                    final MagicCard targetCard ->\r\n                    cardCount+=1;\r\n                    game.doAction(new MagicRemoveCardAction(targetCard,MagicLocationType.Graveyard));\r\n                    game.doAction(new MagicMoveCardAction(targetCard,MagicLocationType.Graveyard,MagicLocationType.BottomOfOwnersLibrary));\r\n                    if(cardCount<4){\r\n                        game.addEvent(this.getPermanentEvent(event.getPermanent(),MagicPayedCost.NO_COST));\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n]\r\n\r\n\r\nthe condition if(cardCount<4) triggers if wrote as if(true) - this way the recursion is called ever again unless you don't have cards in your graveyard left or you choose \"no\". ... which points directly to a problem: im my testruns cardCount had weird numbers, like 923, 4456 and so on. So, to make this happen, I need a variable, which goes stricktly +1 each time executeEvent is called. And only then. Any ideas?",
  "author": "[Landhotel.Westerwald](https://code.google.com/u/Landhotel.Westerwald/)",
  "title": "possible fix for Bow of Nylea",
  "labels": [
    "imported",
    "Priority-Medium",
    "bug",
    "wontfix"
  ],
  "comments": [
    {
      "date": "April 04, 2014 13:53:17",
      "body": "The problem with having variables on cards, is that the AI will be playing many different games at the same time. That would explain the cardCount.\r\n\r\nCurrently multiple-target spells are a no-no, as the AI would have to take into account all possible combinations (in this case, of up to 4 cards in the graveyard) to choose. The total number of permutations would be pretty high.",
      "author": "[ShawnieBoyUK](https://code.google.com/u/ShawnieBoyUK/)"
    },
    {
      "date": "April 04, 2014 14:03:37",
      "body": "you told me before. neverthless I was looking for a solution, if only for myself and further testing purposes... truth to be told: it bugs me.",
      "author": "[Landhotel.Westerwald](https://code.google.com/u/Landhotel.Westerwald/)"
    },
    {
      "date": "April 04, 2014 14:10:46",
      "body": "I don't blame you for trying :) Limits are there to be pushed!",
      "author": "[ShawnieBoyUK](https://code.google.com/u/ShawnieBoyUK/)"
    },
    {
      "date": "April 04, 2014 15:38:06",
      "body": "well, okay, having variables on cards is no good then, because the cards are called a lot. Even I could have a card 4 times at the same time. Roger that. But it would be different to have a variable on the permanent, since the permanents are unique by ID, aren't they? \r\n\r\nSay, if MagicPermanent would have a variable private int track = 0, along with corresponding get and set methods, I could use it as cardCount?",
      "author": "[Landhotel.Westerwald](https://code.google.com/u/Landhotel.Westerwald/)"
    },
    {
      "date": "April 04, 2014 18:01:58",
      "body": "I did it.\r\n\r\nbefore compiling .965 I altered MagicPermanent by adding:\r\n\r\nprivate int trackable = 0;\r\n\r\npublic int getTrackable(){\r\n   return trackable;\r\n}\r\n\r\npublic void setTrackable(int aTrackable){\r\n   this.trackable = aTrackable;\r\n}\r\n\r\nthe new groovy code for Bow_of_Nylea.groovy :\r\n[\r\n    new MagicStatic(MagicLayer.Ability,MagicTargetFilter.TARGET_CREATURE_YOU_CONTROL) {\r\n        @Override\r\n        public void modAbilityFlags(final MagicPermanent source,final MagicPermanent permanent,final Set<MagicAbility> flags) {\r\n            if(permanent.isAttacking()) {\r\n               permanent.addAbility(MagicAbility.Deathtouch, flags);\r\n            }\r\n        }\r\n    },\r\n    new MagicPermanentActivation(new MagicActivationHints(MagicTiming.Main),\"Return\"){\r\n        @Override\r\n        public Iterable<MagicEvent> getCostEvent(final MagicPermanent source) {\r\n            source.setTrackable(0);\r\n            return [\r\n                new MagicTapEvent(source), \r\n                new MagicPayManaCostEvent(source,\"{1}{G}\")\r\n            ];\r\n        }\r\n        @Override\r\n        public MagicEvent getPermanentEvent(final MagicPermanent source,final MagicPayedCost payedCost) {\r\n            return new MagicEvent(\r\n                source,\r\n                new MagicMayChoice(MagicTargetChoice.TARGET_CARD_FROM_GRAVEYARD),\r\n                MagicGraveyardTargetPicker.ExileOpp,\r\n                this,\r\n                \"Put up to \"+(4-source.getTrackable())+\" target cards\\$ from your graveyard on the bottom of your library\"\r\n            );\r\n        }\r\n        @Override\r\n        public void executeEvent(final MagicGame game, final MagicEvent event) {\r\n            if(event.isYes()){\r\n                event.processTargetCard(game, {\r\n                    final MagicCard targetCard ->\r\n                    event.getPermanent().setTrackable(1+event.getPermanent().getTrackable());\r\n                    game.doAction(new MagicRemoveCardAction(targetCard,MagicLocationType.Graveyard));\r\n                    game.doAction(new MagicMoveCardAction(targetCard,MagicLocationType.Graveyard,MagicLocationType.BottomOfOwnersLibrary));\r\n                    if(event.getPermanent().getTrackable()<4){\r\n                        game.addEvent(this.getPermanentEvent(event.getPermanent(),MagicPayedCost.NO_COST));\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n]\r\n\r\n\r\nThere is only one item on the stack - the remaining up to 3 targets will be chosen when the ability resolves. https://www.dropbox.com/s/nnuqya08xzd9wax/Bow_of_Nylea_screenshot.png <- last item gamelog.",
      "author": "[Landhotel.Westerwald](https://code.google.com/u/Landhotel.Westerwald/)"
    },
    {
      "date": "April 04, 2014 23:03:08",
      "body": "Wouldn't it be simpler to get a similar effect by doing addEvent three times? The problem with an extra variable in MagicPermanent is that other card scripts might start using it, then you can't be sure it only increases cause other card script might use it to track some other value.",
      "author": "[melvinzh...@gmail.com](https://code.google.com/u/108278210804167927868/)"
    },
    {
      "date": "April 04, 2014 23:07:39",
      "body": "Correction, will have to create a separate event that doesn't perform the addEvent, otherwise there will be too many. So one way is to define separate event that works on exactly one target. Then in executeEvent of the actvation, add this event three times.",
      "author": "[melvinzh...@gmail.com](https://code.google.com/u/108278210804167927868/)"
    },
    {
      "date": "April 05, 2014 01:40:23",
      "body": "I tried, yet I don't know how. Didn't work out for me.",
      "author": "[Landhotel.Westerwald](https://code.google.com/u/Landhotel.Westerwald/)"
    },
    {
      "date": "April 05, 2014 02:20:08",
      "body": "More than that: I don't understand what you mean by: \"otherwise there will be too many\".\r\n\r\nI seriously tested the recursions. \r\n- after the last card the view switches back to your hand\r\n- there are 4 cards processed at most, tested that: https://www.dropbox.com/s/2bb3f5ztx1imahd/Bow_of_Nylea_2_screenshot.png -> game log shows 4 choices made, even though there is a card in the graveyard left\r\n- since the variable is part of the permanent, and the permanent is unique, there shouldn't be any interferences with it.",
      "author": "[Landhotel.Westerwald](https://code.google.com/u/Landhotel.Westerwald/)"
    },
    {
      "date": "April 05, 2014 02:42:04",
      "body": "I mean my original suggestion of calling game.addEvent(this.getPermanentEvent(event.getPermanent(),MagicPayedCost.NO_COST)) three times will produce too many, in fact infinitely many, since each one of these will add another three.\r\n\r\nAs mentioned creating a variable in MagicPermanent is not recommended, it is impossible to know how other card scripts will use it as it is a global variable that is shared by everyone. For example, consider the case where the ability is activated twice in a row. We would like to avoid such global state.\r\n\r\nA better way is to store the number in the event itself, you can pass it an integer just before the 'this' parameter. Then you can retrieve it in the executeEvent with event.getRefInt. So you can define a function 'def Event' to generate the event with a specific int, then call it with Event(source, 0) in getPermanentEvent, then in executeEvent you can check event.getRefInt() and if less than 4, do game.addEvent(Event(event.getSource(), event.getRefInt() + 1)). See Powerstone_Minefield.groovy on creating function that returns an event.",
      "author": "[melvinzh...@gmail.com](https://code.google.com/u/108278210804167927868/)"
    },
    {
      "date": "April 05, 2014 08:00:58",
      "body": "Finally. \r\n\r\nThanks for all your help. I didn't know about the refInts yet, but your right - with them there is no need for an extra variable.\r\n\r\nTested. Works. That was a tricky one.\r\n\r\nBow_of_Nylea.groovy:\r\n[\r\n    new MagicStatic(MagicLayer.Ability,MagicTargetFilter.TARGET_CREATURE_YOU_CONTROL) {\r\n        @Override\r\n        public void modAbilityFlags(final MagicPermanent source,final MagicPermanent permanent,final Set<MagicAbility> flags) {\r\n            if(permanent.isAttacking()) {\r\n               permanent.addAbility(MagicAbility.Deathtouch, flags);\r\n            }\r\n        }\r\n    },\r\n    new MagicPermanentActivation(new MagicActivationHints(MagicTiming.Main),\"Return\"){\r\n        @Override\r\n        public Iterable<MagicEvent> getCostEvent(final MagicPermanent source) {\r\n            return [\r\n                new MagicTapEvent(source), \r\n                new MagicPayManaCostEvent(source,\"{1}{G}\")\r\n            ];\r\n        }\r\n        @Override\r\n        public MagicEvent getPermanentEvent(final MagicPermanent source,final MagicPayedCost payedCost) {\r\n            return new MagicEvent(\r\n                source,\r\n                source.getController(),\r\n                new MagicMayChoice(MagicTargetChoice.TARGET_CARD_FROM_GRAVEYARD),\r\n                MagicGraveyardTargetPicker.ExileOpp,\r\n                0,\r\n                this,\r\n                \"Put up to 4 target cards\\$ from your graveyard on the bottom of your library. \"\r\n            );\r\n        }\r\n        public MagicEvent FollowUp(final MagicPermanent source, final int refInt) {\r\n            return new MagicEvent(\r\n                source,\r\n                source.getController(),\r\n                new MagicMayChoice(MagicTargetChoice.TARGET_CARD_FROM_GRAVEYARD),\r\n                MagicGraveyardTargetPicker.ExileOpp,\r\n                1+refInt,\r\n                this,\r\n                \"Put up to \"+(3-refInt)+\" target cards\\$ from your graveyard on the bottom of your library. \"\r\n            );\r\n        }\r\n        @Override\r\n        public void executeEvent(final MagicGame game, final MagicEvent event) {\r\n            if(event.isYes()){\r\n                event.processTargetCard(game, {\r\n                    final MagicCard targetCard ->\r\n                    game.doAction(new MagicRemoveCardAction(targetCard,MagicLocationType.Graveyard));\r\n                    game.doAction(new MagicMoveCardAction(targetCard,MagicLocationType.Graveyard,MagicLocationType.BottomOfOwnersLibrary));\r\n                    if(event.getRefInt()<3){\r\n                        game.addEvent(FollowUp(event.getPermanent(),event.getRefInt()));\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n]",
      "author": "[Landhotel.Westerwald](https://code.google.com/u/Landhotel.Westerwald/)"
    },
    {
      "date": "April 05, 2014 17:43:26",
      "body": "**Status:** WontFix  \n",
      "author": "[melvinzh...@gmail.com](https://code.google.com/u/108278210804167927868/)"
    }
  ],
  "content": "_From [Landhotel.Westerwald](https://code.google.com/u/Landhotel.Westerwald/) on April 05, 2014 04:02:40_\n\nI got through the groovy code once more and I have an idea how to manage:\r\n\r\nBow_of_Nylea.groovy:\r\n\r\n[\r\n    new MagicStatic(MagicLayer.Ability,MagicTargetFilter.TARGET_CREATURE_YOU_CONTROL) {\r\n        @Override\r\n        public void modAbilityFlags(final MagicPermanent source,final MagicPermanent permanent,final Set<MagicAbility> flags) {\r\n            if(permanent.isAttacking()) {\r\n               permanent.addAbility(MagicAbility.Deathtouch, flags);\r\n            }\r\n        }\r\n    },\r\n    new MagicPermanentActivation(\r\n        new MagicActivationHints(MagicTiming.Main),\r\n        \"Return\"\r\n    ){\r\n        private int cardCount=0;\r\n        @Override\r\n        public Iterable<MagicEvent> getCostEvent(final MagicPermanent source) {\r\n            return [\r\n                new MagicTapEvent(source), \r\n                new MagicPayManaCostEvent(source,\"{1}{G}\")\r\n            ];\r\n        }\r\n        @Override\r\n        public MagicEvent getPermanentEvent(final MagicPermanent source,final MagicPayedCost payedCost) {\r\n            return new MagicEvent(\r\n                source,\r\n                new MagicMayChoice(MagicTargetChoice.TARGET_CARD_FROM_GRAVEYARD),\r\n                MagicGraveyardTargetPicker.ExileOpp,\r\n                this,\r\n                \"Put up to 4 target cards\\$ from your graveyard on the bottom of your library\"\r\n            );\r\n        }\r\n        @Override\r\n        public void executeEvent(final MagicGame game, final MagicEvent event) {\r\n            if(event.isYes()){\r\n                event.processTargetCard(game, {\r\n                    final MagicCard targetCard ->\r\n                    cardCount+=1;\r\n                    game.doAction(new MagicRemoveCardAction(targetCard,MagicLocationType.Graveyard));\r\n                    game.doAction(new MagicMoveCardAction(targetCard,MagicLocationType.Graveyard,MagicLocationType.BottomOfOwnersLibrary));\r\n                    if(cardCount<4){\r\n                        game.addEvent(this.getPermanentEvent(event.getPermanent(),MagicPayedCost.NO_COST));\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n]\r\n\r\n\r\nthe condition if(cardCount<4) triggers if wrote as if(true) - this way the recursion is called ever again unless you don't have cards in your graveyard left or you choose \"no\". ... which points directly to a problem: im my testruns cardCount had weird numbers, like 923, 4456 and so on. So, to make this happen, I need a variable, which goes stricktly +1 each time executeEvent is called. And only then. Any ideas?\n\n_Original issue: http://code.google.com/p/magarena/issues/detail?id=578_",
  "date": "2014-04-05T04:02:40",
  "state": "closed",
  "gid": 578,
  "link": "http://code.google.com/p/magarena/issues/detail?id=578",
  "owner": ""
}
